<?php declare(strict_types=1);
/** @var $this Railt\Compiler\Compiler */
echo '<?php' . "\n";
?>
/**
 * This file is part of Railt package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
declare(strict_types=1);
<?php
if ($this->namespace) {
    echo "\n" . \sprintf('namespace %s;', $this->namespace) . "\n";
}
?>

use Railt\Lexer\LexerInterface;
use Railt\Parser\Driver\Llk;
use Railt\Parser\Driver\Proxy;
use Railt\Lexer\Driver\NativeRegex;
use Railt\Parser\Grammar;
use Railt\Parser\ParserInterface;
use Railt\Parser\Rule\Alternation;
use Railt\Parser\Rule\Concatenation;
use Railt\Parser\Rule\Repetition;
use Railt\Parser\Rule\Terminal;
use Railt\Parser\GrammarInterface;

/**
 * --- DO NOT EDIT THIS FILE ---
 *
 * Class <?=$this->class; ?> has been auto-generated.
 * Generated at: <?=\date('d-m-Y H:i:s') . "\n"; ?>
 *
 * --- DO NOT EDIT THIS FILE ---
 */
class <?=$this->class; ?> extends Proxy
{
<?php foreach ($this->getLexer()->getTokenDefinitions() as $token): ?>
    public const <?=$token->getName(); ?> = <?=$this->render($token->getName()); ?>;
<?php endforeach; ?>

    /**
     * Lexical tokens list.
     *
     * @var string[]
     */
    protected const LEXER_TOKENS = [
<?php foreach ($this->getLexer()->getTokenDefinitions() as $token): ?>
        self::<?=$token->getName(); ?> => <?=$this->render($token->getPcre()); ?>,
<?php endforeach; ?>
    ];

    /**
     * List of skipped tokens.
     *
     * @var string[]
     */
    protected const LEXER_SKIPPED_TOKENS = [
<?php foreach ($this->getLexer()->getTokenDefinitions() as $token):
    if ($token->isKeep()) {
        continue;
    }
?>
        <?=$this->render($token->getName()); ?>,
<?php endforeach; ?>
    ];

    /**
     * List of rule delegates.
     *
     * @var string[]
     */
    protected const PARSER_DELEGATES = [
<?php foreach ($this->getGrammar()->getDelegates() as $rule => $delegate): ?>
        <?=$this->render($rule); ?> => \<?=$delegate; ?>::class,
<?php endforeach; ?>
    ];

    /**
     * Parser root rule name.
     *
     * @var string
     */
    protected const PARSER_ROOT_RULE = <?=$this->render($this->getGrammar()->beginAt()); ?>;

    /**
     * <?=$this->class; ?> constructor.
     */
    public function __construct()
    {
        parent::__construct($this->getParser());
    }

    /**
     * @param string $lexeme
     * @return string
     */
    public static function pattern(string $lexeme): string
    {
        return \sprintf('/^%s$/', static::LEXER_TOKENS[$lexeme]);
    }

    /**
     * @param string $lexeme
     * @param string $value
     * @return bool
     */
    public static function match(string $lexeme, string $value): bool
    {
        return (bool)\preg_match(static::pattern($lexeme), $value);
    }

    /**
     * @return ParserInterface
     */
    protected function getParser(): ParserInterface
    {
        return new Llk($this->getLexer(), $this->getGrammar());
    }

    /**
     * @return LexerInterface
     */
    protected function getLexer(): LexerInterface
    {
        return new NativeRegex(static::LEXER_TOKENS, static::LEXER_SKIPPED_TOKENS);
    }

    /**
     * @return GrammarInterface
     */
    protected function getGrammar(): GrammarInterface
    {
        return new Grammar($this->getGrammarRules(), static::PARSER_ROOT_RULE, static::PARSER_DELEGATES);
    }

    /**
     * @return array|\Railt\Parser\Rule\Rule[]
     */
    protected function getGrammarRules(): array
    {
        return [
            <?=\implode(', ' . "\n            ", require __DIR__ . '/rules.tpl.php'); ?>

        ];
    }
}
