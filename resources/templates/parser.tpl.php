<?php declare(strict_types=1);
/** @var $this Railt\Compiler\Compiler */
echo '<?php' . "\n";
?>
/**
 * This file is part of Railt package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
declare(strict_types=1);
<?php
if ($this->namespace) {
    echo "\n" . \sprintf('namespace %s;', $this->namespace) . "\n";
}
?>

use Railt\Lexer\Factory;
use Railt\Lexer\LexerInterface;
use Railt\Parser\Grammar;
use Railt\Parser\Driver\Llk;
use Railt\Parser\ParserInterface;
use Railt\Parser\Rule\Alternation;
use Railt\Parser\Rule\Concatenation;
use Railt\Parser\Rule\Repetition;
use Railt\Parser\Rule\Terminal;
use Railt\Parser\GrammarInterface;

/**
 * --- DO NOT EDIT THIS FILE ---
 *
 * Class <?=$this->class; ?> has been auto-generated.
 * Generated at: <?=\date('d-m-Y H:i:s') . "\n"; ?>
 *
 * --- DO NOT EDIT THIS FILE ---
 */
class <?=$this->class; ?> extends Llk
{
<?php foreach ($this->getLexer()->getTokenDefinitions() as $token): ?>
    public const <?=$token->getName(); ?> = <?=$this->render($token->getName()); ?>;
<?php endforeach; ?>

    /**
     * Lexical tokens list.
     *
     * @var string[]
     */
    protected const LEXER_TOKENS = [
<?php foreach ($this->getLexer()->getTokenDefinitions() as $token): ?>
        self::<?=$token->getName(); ?> => <?=$this->render($token->getPcre()); ?>,
<?php endforeach; ?>
    ];

    /**
     * List of skipped tokens.
     *
     * @var string[]
     */
    protected const LEXER_SKIPPED_TOKENS = [
<?php foreach ($this->getLexer()->getTokenDefinitions() as $token):
    if ($token->isKeep()) {
        continue;
    }
?>
        <?=$this->render($token->getName()); ?>,
<?php endforeach; ?>
    ];

    /**
     * @var int
     */
    protected const LEXER_FLAGS = Factory::LOOKAHEAD;

    /**
     * List of rule delegates.
     *
     * @var string[]
     */
    protected const PARSER_DELEGATES = [
<?php foreach ($this->getGrammar()->getDelegates() as $rule => $delegate): ?>
        <?=$this->render($rule); ?> => \<?=$delegate; ?>::class,
<?php endforeach; ?>
    ];

    /**
     * Parser root rule name.
     *
     * @var string
     */
    protected const PARSER_ROOT_RULE = <?=$this->render($this->getGrammar()->beginAt()); ?>;

    /**
     * BaseParser constructor.
     * @throws \InvalidArgumentException
     * @throws \Railt\Lexer\Exception\BadLexemeException
     */
    public function __construct()
    {
        parent::__construct($this->bootLexer(), $this->bootGrammar());
    }

    /**
     * @return LexerInterface
     * @throws \InvalidArgumentException
     * @throws \Railt\Lexer\Exception\BadLexemeException
     */
    protected function bootLexer(): LexerInterface
    {
        return Factory::create(static::LEXER_TOKENS, static::LEXER_SKIPPED_TOKENS, static::LEXER_FLAGS);
    }

    /**
     * @return GrammarInterface
     */
    protected function bootGrammar(): GrammarInterface
    {
        return new Grammar($this->bootRules(), static::PARSER_ROOT_RULE, static::PARSER_DELEGATES);
    }

    /**
     * @return array|\Railt\Parser\Rule\Rule[]
     */
    protected function bootRules(): array
    {
        return [
        <?=\implode(', ' . "\n            ", require __DIR__ . '/rules.tpl.php'); ?>

        ];
    }
}
