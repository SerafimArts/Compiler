<?php declare(strict_types=1);
/** @var $this Railt\Compiler\Compiler */
echo '<?php' . "\n";
?>
/**
 * This file is part of Railt package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
declare(strict_types=1);
<?php
if ($this->namespace) {
    echo "\n" . \sprintf('namespace %s;', $this->namespace) . "\n";
}
?>

use Railt\Lexer\Factory;
use Railt\Lexer\LexerInterface;
use Railt\Parser\Driver\Llk;
use Railt\Parser\Driver\Stateful;
use Railt\Parser\Grammar;
use Railt\Parser\ParserInterface;
use Railt\Parser\Rule\Alternation;
use Railt\Parser\Rule\Concatenation;
use Railt\Parser\Rule\Repetition;
use Railt\Parser\Rule\Terminal;
use Railt\Parser\GrammarInterface;

/**
 * --- DO NOT EDIT THIS FILE ---
 *
 * Class <?=$this->class; ?> has been auto-generated.
 * Generated at: <?=\date('d-m-Y H:i:s') . "\n"; ?>
 *
 * --- DO NOT EDIT THIS FILE ---
 */
class <?=$this->class; ?> extends Stateful
{
<?php foreach ($this->getLexer()->getTokenDefinitions() as $token): ?>
    public const <?=$token->getName(); ?> = <?=$this->render($token->getName()); ?>;
<?php endforeach; ?>

    /**
     * Lexical tokens list.
     *
     * @var string[]
     */
    private const LEXER_TOKENS = [
<?php foreach ($this->getLexer()->getTokenDefinitions() as $token): ?>
        self::<?=$token->getName(); ?> => <?=$this->render($token->getPcre()); ?>,
<?php endforeach; ?>
    ];

    /**
     * List of skipped tokens.
     *
     * @var string[]
     */
    private const LEXER_SKIPPED_TOKENS = [
<?php foreach ($this->getLexer()->getTokenDefinitions() as $token):
    if ($token->isKeep()) {
        continue;
    }
?>
        <?=$this->render($token->getName()); ?>,
<?php endforeach; ?>
    ];

    /**
     * @var int
     */
    private const LEXER_FLAGS = Factory::LOOKAHEAD;

    /**
     * List of rule delegates.
     *
     * @var string[]
     */
    private const PARSER_DELEGATES = [
<?php foreach ($this->getGrammar()->getDelegates() as $rule => $delegate): ?>
        <?=$this->render($rule); ?> => \<?=$delegate; ?>::class,
<?php endforeach; ?>
    ];

    /**
     * Parser root rule name.
     *
     * @var string
     */
    private const PARSER_ROOT_RULE = <?=$this->render($this->getGrammar()->beginAt()); ?>;

    /**
     * @return ParserInterface
     * @throws \InvalidArgumentException
     * @throws \Railt\Lexer\Exception\BadLexemeException
     */
    protected function boot(): ParserInterface
    {
        return new Llk($this->bootLexer(), $this->bootGrammar());
    }

    /**
     * @return LexerInterface
     * @throws \InvalidArgumentException
     * @throws \Railt\Lexer\Exception\BadLexemeException
     */
    private function bootLexer(): LexerInterface
    {
        return Factory::create(self::LEXER_TOKENS, self::LEXER_SKIPPED_TOKENS, self::LEXER_FLAGS);
    }

    /**
     * @return GrammarInterface
     */
    private function bootGrammar(): GrammarInterface
    {
        return new Grammar([
            <?=\implode(', ' . "\n            ", require __DIR__ . '/rules.tpl.php');?>

        ], self::PARSER_ROOT_RULE, self::PARSER_DELEGATES);
    }
}
